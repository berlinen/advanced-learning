## 面向对象变成/原型及原型链

### 面向对象编程

#### 什么是面向对象编程

⾯面向对象是⼀一种编程思想，经常被拿来和⾯面向过程⽐比较。

其实说的简单点，

⾯面向过程关注的重点是动词，是分析出解决问题需要的步骤，然后编写函数实现每个步骤，最 后依次调⽤用函数。

⽽面向对象关注的重点是主谓，是把构成问题的事物拆解为各个对象，而拆解出对象的⽬的也不是为了了实现某个步骤，而是为了描述这个事物在当前问题中的各种行为。

##### ⾯面向对象的特点是什么?

封装:让使用对象的⼈不考虑内部实现，只考虑功能使用 把内部的代码保护起来，只留出⼀一 些 api 接口供用户使用

继承:就是为了代码的复用，从⽗类上继承出⼀一些方法和属性，⼦类也有⾃己的⼀些属性

多态:是不同对象作用于同⼀操作产生不同的效果。多态的思想实际上是把“想做什么”和“谁去 做“分开

##### ⽐如下棋的过程,

⾯向过程是这样的:开局  -> ⽩⽅方下棋  -> 棋盘展示  -> 检查胜负  -> ⿊⽅下棋  -> 棋盘展示  -> 检查  -> 胜负  -> 循环

用代码表示可能是⼀连串串函数的调用
init();
whitePlay(); // ⾥里里⾯面实现⼀一遍下棋的操作 repaint(); // 棋盘展示
check();
blackPlay(); // 再单独实现⼀一遍下棋的操作 repaint(); // 棋盘展示
check();

面向对象是这样的:棋盘.开局 -> 选手.下棋 -> 棋盘.重新展示 -> 棋盘.检查胜负 -> 选手.下棋 -> 棋盘.重新展示 -> 棋盘.检查胜负

用代码表示可能是这样的
const checkerBoard = new CheckerBoard(); // CheckerBoard 类内部封账了了棋盘的操作，⽐比 如初始化棋盘，检查胜负关系等

const whitePlayer = new Player(‘white’); // Player 类内部封装了了各种玩家的操作，⽐比如等待， 落棋，悔悔棋

const blackPlayer = new Player(‘black’);

whitePlayer.start(); // start ⽅方法的结束，内部封装了了或者通过事件发布触发

checkerBoard.repaint()

checkerBoard.check()的调⽤用

blackPlayer.start();

你只需要调用 new ⼀个 player, 然后调用 start 方法，也就是说我们只需要关注⾏为，⽽不需 要知道内部到底做了什么。

#### 在上⾯的例子中，⾯向对象的特性是怎么表现出来的呢?

封装:Player, CheckerBoard 类，使用的时候并不需要知道内部实现了什么，只需要考虑暴露 出的 api 的使⽤

继承:whitePlayer 和 blackPlayer 都继承⾃自 Player，都可以直接使用 Player 的各种⽅法和属 性

多态:whitePlayer.start() 和 blackPlayer.start() 下棋的颜色分别是⽩色和⿊色

#### 什什么时候适合使⽤用⾯面向对象

可以看出来，在⽐比较复杂的问题⾯面前，或者参与⽅方较多的时候，⾯面向对象的编程思想可以很好 的简化问题，并且能够更更好的扩展和维护。

⽽而在⽐比较简单的问题⾯面前，⾯面向对象和⾯面向过程其实差异并不不明显，也可以⼀一步⼀一步地按照步 骤来调⽤用。


