## 继承

### 原型链继承

#### 实现

```js
function Parent () {
  this.name = 'berlin';
};

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child () {};
// Parent的实例例同时包含实例例属性⽅方法和原型属性⽅方法，所以把new Parent()赋值给 Child.prototype。
// 如果仅仅Child.prototype = Parent.prototype，那么Child只能调⽤用getName，⽆无法调 ⽤用.name
// 当Child.prototype = new Parent()后， 如果new Child()得到⼀一个实例例对象child，那么
// child.__proto__ === Child.prototype;
// Child.prototype.__proto__ === Parent.prototype
// 也就意味着在访问child对象的属性时，如果在child上找不不到，就会去Child.prototype去找，如 果还找不不到，就会去Parent.prototype中去找，从⽽而实现了了继承。
Child.prototype = new Parent();
// 因为constructor属性是包含在prototype⾥里里的，上⾯面重新赋值了了prototype，所以会导致Child的 constructor指向[Function: Parent]，有的时候使⽤用child1.constructor判断类型的时候就会出 问题
// 为了了保证类型正确，我们需要将Child.prototype.constructor 指向他原本的构造函数Child
Child.protoType.constructor = Child;
```

#### 缺陷

1. 如果有属性是引⽤用类型的，⼀一旦某个实例例修改了了这个属性，所有实例例都会受到影响

```js
function Parent () {
  this.actions = ['eat', 'run']
}

function Child () {}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child1 = new Child();
const child2 = new Child();

child1.actions.pop();

console.log(child1.actions)  // ['eat']
console.log(child2.actions)  // ['eat']
```

2. 创建 Child 实例例的时候，不不能传参

### 构造函数继承

解决原型链继承的两个问题

```js
function Parent() {
  this.actions = ["eat", "run"];
  this.name = "parentName";
}

function Child () {
  Parent.call(this)
}

const child1 = new Child();
const child2 = new Child();

child1.actions.pop();

console.log(child1.actions); // ['eat']
console.log(child1.actions); // ['eat', 'run']

```

#### 解决传参数

```js
function Parent(name, actions) {
  this.actions = actions;
  this.name = name;
}

function Child (id, name, actions) {
  Parent.apply(this, Array.from(arguments).slice(1));
  this.id = id;
}

const child1 = new Child(1, "c1", ["eat"]);
const child2 = new Child(2, "c2", ["sing", "jump", "rap"]);

console.log(child1.name); // { actions: [ 'eat' ], name: 'c1', id: 1 }
console.log(child2.name); // { actions: [ 'sing', 'jump', 'rap' ], name: 'c2', id: 2 }
```

#### 问题

属性或者⽅方法想被继承的话，只能在构造函数中定义。⽽而如果⽅方法在构造函数内定义了了，那么 每次创建实例例都会创建⼀一遍⽅方法，多占⼀一块内存。

```js
function Parent(name, actions) {
  this.actions = actions;
  this.name = name;
  this.eat = function () {
    console.log(`${name} - eat`);
  }
}

function Child(id) {
  Parent.apply(this, Array.prototype.slice.call(arguments, 1));
  this.id = id;
}

const child1 = new Child(1, "c1", ["eat"]);
const child2 = new Child(2, "c2", ["sing", "jump", "rap"]);
console.log(child1.eat === child2.eat); // false
```

### 组合继承
